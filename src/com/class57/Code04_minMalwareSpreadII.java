package com.class57;

import java.util.Arrays;

public class Code04_minMalwareSpreadII {

    // 如果测试数据变大,就改变值
    public static int MAXN  = 301;

    // eg: [3,6,103]
    // virus[3] = true ;
    //virus[103] = true ;
    // 方便查询
    public static  boolean[] virus = new boolean[MAXN];

    // 每个源头点删掉的话,能拯救多少点的数据
    public static int[] cnts = new int[MAXN];

    //集合的标签:  集合的感染点是什么
    // a: 代表点,整个集合源头是 infect[a]
    //infect[a] == -1  : 目前这个集合没有发现源头
    //infect[a] >= 0  : 目前这个集合源头是infect[a]
    //infect[a] == -2  : 目前这个集合源头不止一个,已经无法拯救了
    public static int[] infect = new int[MAXN];

    // 并查集有固定信息
    public static int[] father = new int[MAXN];

    // 集合的标签: 集合的大小是多少
    public static int[] size = new int[MAXN];

    // 集合一定只放普通点,源头根本不参与集合,也不是元素!

    public static void build(int n ,int[] initial) {
        for (int i = 0 ;i < n ;i++){
            virus[i] = false;
            cnts[i] = 0 ;
            infect[i] = -1;
            size[i]  = 1;
            father[i] = i;
        }
        for (int i: initial){
            virus[i] = true;
        }
    }

    public static int find(int i ){
        if (i != father[i]){
            father[i] = find(father[i]);
        }
        return father[i];
    }

    public static void union(int x , int y ){
        int fx = find(x);
        int fy = find(y);
        if (fx != fy){
            father[fx] = fy;
            size[fy] += size[fx];
        }
    }

    public  static int minMalwareSpread(int[][] graph , int[] initial) {
        int n =graph.length;
        build(n , initial);
        // 不是病毒的点,普通点合并!
        for (int i = 0 ; i < n ; i++) {
            for (int j = 0 ; j < n ; j++){
                if (graph[i][j] == 1 && !virus[i] && !virus[j]){
                    union(i,j);
                }
            }
        }
        //病毒周围的普通点去设置源头!
        for (int sick : initial){
            for (int neighbor = 0 ; neighbor < n ; neighbor++){
                //  邻居不能是我自己        邻居不能是病毒         真的有连接
                if (sick != neighbor && !virus[neighbor] && graph[sick][neighbor] == 1 ) {
                    int fn = find(neighbor);
                    if (infect[fn] == -1 ) { // 代表节点没有感染过
                        infect[fn] = sick;
                        //     源头点不等于-2       源头点之前设置过但不是此时的
                    }else if (infect[fn] != -2 && infect[fn] != sick){
                        infect[fn] = -2 ;
                    }
                }
            }
        }
        //统计拯救数据
        for (int i = 0 ;i < n ; i++) {
            // 不是代表点,不看
            if (i == find(i) && infect[i] >= 0) {
                cnts[infect[i]] += size[i];
            }
        }
        //排个序,返回能够拯救最多并且索引较小的源头
        Arrays.sort(initial);
        int ans = initial[0];
        int max = cnts[ans];
        for (int i : initial) {
            if (cnts[i] > max) {
                ans = i ;
                max = cnts[i];
            }
        }
        return ans ;
    }
}
